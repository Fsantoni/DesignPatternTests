Class Adapter:
si testa solo la variabile interna boolean che corrisponde allo stato, con criterio "all uses"

considerati i path di esecuzione si hanno

//Adapter() GetInt 
//Adapter() getBool 
Adapter() setInt getInt 
//Adapter() setInt getBool 

Adapter() setbool getInt 
Adapter() setbool getbool <- LEGACY (può essere errato, ma non si sta testando, al massimo si isola coi mock)
//RIGUARDAMI

Sono stati fatti sia unit test che integration tests, in particolare NON ci sono classi di cui fare mocks in quanto 1) l'unico oggetto istanziato è l'adapter da testare e 2)l'unica altra classe implementata è legacy, quindi già sicura e testata per ipotesi


Object adapter:

si testa anche adapteeOpposite, il test risulta errato in quanto non possiamo conoscere l'effettiva topologia durante l'esecuzione.
Risulterebbe corretto se fossero approntate misure per trattare estensioni dell'Adaptee o se lo stesso fosse dichiarato "final"

Testiamo quindi direttamente la variabile di stato adaptee

si considerano defs ogni modifica dello stato interno dell'oggetto "adaptee" e use ogni "utilizzo" di campi o metodi interni dell'oggetto (avesse metodi o campi statici, corrisponderebbero ad elementi della classe, che dovrei testare separatamente)  

//Adapter() getInt() 
Adapter SetInt getInt 
//RIGUARDAMI

In particolare si è dato un test con variabile che eredita da Adaptee


Composite:

testo la variabile "children", vettore contenente le parti di Composite

getValue lo utilizza come Use, essendo solo a destra non implica però che sia solo use, semplicemente i metodi chiamati su esso non danno side effects.

Component add getchild
Component add getValue
Component add add remove getChild
Component add add remove getValue 
//RIGUARDAMI

State:

come cambino gli stati interni agli state concreti non ci interessa troppo, si vuole testare ogni volta che state cambia

StateCont() writeOut 
StateCont() setState write
StateCont() writeOut writeOut