Class Adapter:
si testa solo la variabile interna boolean che corrisponde allo stato, con criterio "all uses"

considerati i path di esecuzione si hanno

Adapter() GetInt <- il caso è ripetuto
Adapter() getBool  <- non è legacy, adapter() è nuovo, ma il caso è ripetuto 

Adapter() setInt getInt <- si caso nuovo
Adapter() setInt getBool <- non legacy MA contenuto sopra

Adapter() setbool getInt <- SI, caso nuovo 
Adapter() setbool getbool <- LEGACY, e in ogni caso lo stesso contenuto sopra


Sono stati fatti sia unit test che integration tests, in particolare NON ci sono classi di cui fare mocks in quanto 1) l'unico oggetto istanziato è l'adapter da testare e 2)l'unica altra classe implementata è legacy, quindi già sicura e testata per ipotesi


Object adapter:

si testa anche adapteeOpposite, il test risulta errato in quanto non possiamo conoscere l'effettiva topologia durante l'esecuzione.
Risulterebbe corretto se fossero approntate misure per trattare estensioni dell'Adaptee o se lo stesso fosse dichiarato "final"

Testiamo quindi direttamente la variabile di stato adaptee

si considerano defs ogni modifica dello stato interno dell'oggetto "adaptee" e use ogni "utilizzo" di campi o metodi interni dell'oggetto (avesse metodi o campi statici, corrisponderebbero ad elementi della classe, che dovrei testare separatamente)  

Adapter() getInt() <- no, contenuto sotto
Adapter SetInt getInt <- SI

In particolare si è dato un test con variabile che eredita da Adaptee


Composite:

testo la variabile "children", vettore contenente le parti di Composite

getValue lo utilizza come Use, essendo solo a destra non implica però che sia solo use, semplicemente i metodi chiamati su esso non danno side effects.

Component add getchild
Component add getValue
Component add add remove getChild
Component add add remove getValue 
