Class Adapter:
	si testa solo la variabile interna boolean che corrisponde allo stato, con criterio "all uses"
	
	considerati i path di esecuzione si hanno
	
	Adapter() GetInt 
	Adapter() GetBool 
	Adapter() setInt getInt 
	Adapter() setInt getBool 
	
	Adapter() setbool getInt 
	Adapter() setbool getbool <- LEGACY (può essere errato, ma non si sta testando, al massimo si isola coi mock)
	
	Potrei fare Getint[getBool] e non GetBool in quanto il primo corrisponde a un def clear path che passa da due USE, problema è che non riesco a testare la prima parte del path poichè il parametro passato dal "privato" getbool non lo riesco a catturare
	
	Sono stati fatti sia unit test che integration tests, in particolare NON ci sono classi di cui fare mocks in quanto 1) l'unico oggetto istanziato è l'adapter da testare e 2)l'unica altra classe implementata è legacy, quindi già sicura e testata per ipotesi
	

Object adapter:

	si testa anche adapteeOpposite, il test risulta errato in quanto non possiamo conoscere l'effettiva topologia durante l'esecuzione.
	Risulterebbe corretto se fossero approntate misure per trattare estensioni dell'Adaptee o se lo stesso fosse dichiarato "final"
	
	Testiamo quindi direttamente la variabile di stato adaptee
	
	si considerano defs ogni modifica dello stato interno dell'oggetto "adaptee" e use ogni "utilizzo" di campi o metodi interni dell'oggetto (avesse metodi o campi statici, corrisponderebbero ad elementi della classe, che dovrei testare separatamente)  
	
	Adapter() getInt() 
	Adapter SetInt getInt 
	
	
	In particolare si è dato un test con variabile che eredita da Adaptee


Composite:

	testo la variabile "children", vettore contenente le parti di Composite
	
	getValue lo utilizza come Use; l'essere unicamente a destra non implica però che sia solo use, semplicemente i metodi chiamati su esso non danno side effects.
	
	Component getChild
	Component getValue
	Component add getchild
	Component add getValue
	Component add add remove getChild
	Component add add remove getValue 
	
	si è quindi testata la topologia coprendo con casi di test i path 
	
	Foglia
	Composite Composite
	Composite Foglia
	
	si è quindi testato il differente trattamento rispetto a metodi composti su 
	Foglia
	
	
	IN PARTICOLARE si ha che i test su responsabilità ortogonali si reincontrano su un particolare caso con topologia ?? e metodo GetValue essendo metodo contenente delega e use

State:

	come cambino gli stati interni agli state concreti non ci interessa troppo, si vuole testare ogni volta che state cambia
	
	StateCont() writeOut 
	StateCont() setState write
	StateCont() writeOut writeOut
	
	in particolare si esegue l'ultimo in modo che il penultimo writeOut sia un Def nell'integration test: equivale a testare la "correttezza" dell'implementazione dei Concrete,
	//NON NECESSARIO PER ALL USES, writeOut NON è Def ma esegue funzione che è def -> SOLO UN ALTRO PATH POSSIBILE 
	Li testo solo per vedere se funzionino, non gli dedico separati Unit Tests (che andrebbero fatti su ConcreteClass1 e 2) poichè non li vedo centrali nel mio fault model
	
	nello unit test io testo solo la mia classe, in particolare non considero i Concrete: come portano a chiamare SetState non mi interessa, voglio solo che SetState stesso e writeOutput se presi isolati funzionino
	
Decorator:

 	testo topologia, potrei fare con un unica singola copertura degli edges, decido di fare "più simile a all uses"	es. se ConcComp lo vedo come use lo devo raggiungere dai più modi possibili
 	ConcreteComp
 	DecoratorComp
 	DecorDecorComp
 	
 	non si testa su null poichè quello è un errore di chi ha creato (factory) e gli si delega tale responsabilità
 	