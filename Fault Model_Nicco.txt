Info Utili
	1 Il  flusso di controllo dipende da quale funzione è chiamata nel main
	2 Le relazioni fra classi possono non essere esplicitate in un puntatore o variabile, ma dipendere dai parametri passati nelle chiamate ai loro metodi, 
	3 Topologia ovvero rapporti fra oggetti è dinamica: solo alla creazione di un oggetto viene deciso quale altro oggetto esso contenga o con quali altri oggetti si rapporti
	4 Stato e concorrenza: le variabili di oggetti mantengono stato, ed hanno durata di vita globale <- DA TESTARE QUASI SEMPRE
	5 Polimorfismo: porta complicazioni e incertezze nell'esecuzione per la presenza di differenti "stesse" funzioni, DA TESTARE

Adapter:

data una classe legacy(CHE SUPPONGO CORRETTA) voglio permetterne l'accesso con una particolare interfaccia ed eventualmente aggiungere funzionalità 

- Class Adapter
 	- la nuova classe non è istanza della legacy o del interfaccia-> va testato che tipo di classe è Adapter rispetto Adaptee
 	- l'interfaccia non permette di operare sulla classe -> vanno testate i metodi pubblici dell'interfaccia TargetInterfaces

 -Object Adapter
 	-l'interfaccia non permette di operare sulla classe -> vanno testati i metodi pubblici
 	-l'oggetto contenuto può avere overloads, comportamenti dei metodi pubblici che modificano possono non essere determinati 
 		testare il suo polimorfismo ( in particolare se ha variabili interne)

Decorator:
 
 aggiunge dinamicamente responsabilità ad un oggetto in modo da estenderne le funzionalità. E' visto come evoluzione
 del Pattern Proxy verso una struttura ripetitiva.
 
 - posso testare Decorator: verifico se essa possiede un riferimento all'oggetto Component
 - testo che tipo di classe è Decorator rispetto a Component
 - testo  l'oggetto di Concrete Component, per vedere se ha le caratteristiche per l'aggiunta di resp.(???)
 - testo metodi pubblici di Concrete Decorator, se modificano Component (forse grande cazzata)
 - sarebbe interessante fare una valutazione della memoria occupata al crescere di lista ogg.
 - test su polimorfismo
 - test su topologia
 
Proxy:
 
 fornisce rappresentazione di un oggetto di accesso difficle o che richiede un tempo importante per l'accesso.
 
 - posso testare che tipo di classe è Proxy rispetto a SubjectInterface
 - test su polimorfismo (ossia sulla ereditarietà)
 - test sull'accesso al RealSubject
 - test sulla topologia dell'oggetto instanziato dal RealSubject
 
Observer:
 
 consente la definizione di associazioni di dipenenza di molti oggetti verso di uno, in modo che se quest'ultimo
 cambia il suo stato, tutti gli altri sono notificati e aggiornati automaticamente
 
 - test sulla responsabilità dell'observer 
 - test metodi attach/detach
 - testo che tipo di classe è ConcreteSubject rispetto a Subject
 - testo i metodi di aggiornamento di ConcreteObserver
 
Visitor:
 
 rappresenta un'operazione da essere eseguita in una collezione di elementi di una struttura.
 
 - testo che tipo di classe è ConcreteVisitor rispetto a Visitor
 - testo le operazioni di visita, implementate di Visitor (????)
 - test su operazione accept e sul suo riferimento Visitor passato come argomento
 - test su ObjectStructure sulla possibilità di accettare la visita dei suoi componenti
  
State:
 
consente ad un oggetto modificare il suo comportamento quando il suo stato interno cambia

- testo che tipo di classe è ConcreteState rispetto a State
- testo l'oggeto di Context che deve essere riferimento per ConcreteState
- posso testare una classe tentando il condizionamento del suo comportamento in base ad uno stato interno


Composite: (finire)

consente la costruzione di gerarchie di oggetti composti

- testo che tipo di classe è Composite rispetto a Component
- 
- 
- 
 
 